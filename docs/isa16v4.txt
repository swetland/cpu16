instruction formats      constant encodings    alu opcodes
-----------------------  -------------------   --------------------
  FED CBA 987 654 3210                         000 add   R = A + B
A fff bbb aaa ccc 0ooo                         001 sub   R = A - B
B sii iii aaa ccc 0ooo   si6          siiiii   010 and   R = A & B
C sii iii kkk ccc 0ooo   si9       skkkiiiii   011 or    R = A | B
D sii iii xjj jjj 0ooo   si11    sjjjjjiiiii   100 xor   R = A ^ B
E sii iii aaa mxx 0ooo   si7         smiiiii   101 slt   R = A < B
F sii iii aaa ccc 1fff   si6          siiiii   110 sge   R = A >= B
G sii iii jjj jjj 0ooo   si12   sjjjjjjiiiii   111 mul   R = A * B

instruction encodings
---------------------
A 0000 alu Rc, Ra, Rb     Rc = Ra <fn> Rb
? 0001 <expansion>
G 0010 ext si12           Ex = 1*, Ev = si12[11:0]
C 0011 mov Rc, si9        Rc = Ex ? { Ev, si9[3:0] } : si9
B 0100 lw Rc, [Ra, si6]   Rc = mem[Ra + si6]
B 0101 sw Rc, [Ra, si6]   mem[Ra + si6] = Rc
D 0110 0 b si11           PC = PC + si11
D 0110 1 bl si11          R7 = PC + 1, PC = PC + si11
E 0111 00 bz Ra, si7      (Ra == 0) ? PC = PC + si7
E 0111 01 bnz Ra, si7     (Ra != 0) ? PC = PC + si7
E 0111 10 b Ra            PC = Ra
E 0111 11 bl Ra           R7 = PC + 1, PC = Ra
F 1fff alu Rc, Ra, si6    Rc = Ra <fn> ( Ex ? { Ev, si6[3:0] } : si6 )

* Ex reset to 0 after all ops but "ext"

notes
-----
- consider changing ext to use si10 instead and the reclaimed two bits
  to open up more instruction set space
- consider allowing ext to work with b/bl and/or bz/bnz for long branches
- in which case maybe si11->si10 and compact branch instruction footprint
  a bit too

